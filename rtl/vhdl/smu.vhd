
-- Thanks for XHDL
--/////////////////////////////////////////////////////////////////
--////                                    //////
--/////////////////////////////////////////////////////////////////
--/                                                             ///
--/ This file is generated by Viterbi HDL Code Generator(VHCG)  ///
--/ which is written by Mike Johnson at OpenCores.org  and      ///
--/ distributed under GPL license.                              ///
--/                                                             ///
--/ If you have any advice,                                     ///
--/ please email to jhonson.zhu@gmail.com                       ///
--/                                                             ///
--/////////////////////////////////////////////////////////////////
--/////////////////////////////////////////////////////////////////
--/////////////////////////////////////////////////////////////////
--////                                    //////
--/////////////////////////////////////////////////////////////////
--/                                                             ///
--/ This file is generated by Viterbi HDL Code Generator(VHCG)  ///
--/ which is written by Mike Johnson at OpenCores.org  and      ///
--/ distributed under GPL license.                              ///
--/                                                             ///
--/ If you have any advice,                                     ///
--/ please email to jhonson.zhu@gmail.com                       ///
--/                                                             ///
--/////////////////////////////////////////////////////////////////
--/////////////////////////////////////////////////////////////////

-- 2^(`U+`V)
-- 2^(`U)
-- just for test, not support state-set division.

LIBRARY IEEE;
USE IEEE.std_logic_1164.all;
USE IEEE.std_logic_unsigned.all;
Use work.vhcg_pkg.all;
ENTITY smu IS
   PORT (
      mclk                    : IN std_logic;
      rst                     : IN std_logic;
      valid                   : IN std_logic;
      shift_cnt               : IN std_logic;
      adr0_shift              : IN std_logic;
      adr1_shift              : IN std_logic;
      wr_sm0                  : IN std_logic_vector(8 - 1 DOWNTO 0);
      wr_sm1                  : IN std_logic_vector(8 - 1 DOWNTO 0);
      rd_sm0                  : OUT std_logic_vector(8 - 1 DOWNTO 0);
      rd_sm1                  : OUT std_logic_vector(8 - 1 DOWNTO 0));
END smu;

ARCHITECTURE translated OF smu IS

   TYPE vhcg_3 IS ARRAY (2 - 1 DOWNTO 0) OF std_logic_vector(8 - 1 DOWNTO 0);

   SIGNAL regfbank0                :  vhcg_3;
   SIGNAL regfbank1                :  vhcg_3;
   SIGNAL wr_sm0_shift             :  std_logic_vector(8 - 1 DOWNTO 0);
   SIGNAL wr_sm1_shift             :  std_logic_vector(8 - 1 DOWNTO 0);
   SIGNAL rd_sm0_shift             :  std_logic_vector(8 - 1 DOWNTO 0);
   SIGNAL rd_sm1_shift             :  std_logic_vector(8 - 1 DOWNTO 0);
   SIGNAL i                        :  integer;
   SIGNAL rd_sm0_vhcg1             :  std_logic_vector(8 - 1 DOWNTO 0);
   SIGNAL rd_sm1_vhcg2             :  std_logic_vector(8 - 1 DOWNTO 0);

BEGIN
   rd_sm0 <= rd_sm0_vhcg1;
   rd_sm1 <= rd_sm1_vhcg2;

   PROCESS (shift_cnt, rd_sm0_shift, rd_sm1_shift)
      VARIABLE rd_sm0_vhcg1_vhcg4  : std_logic_vector(8 - 1 DOWNTO 0);
      VARIABLE rd_sm1_vhcg2_vhcg5  : std_logic_vector(8 - 1 DOWNTO 0);
   BEGIN
      CASE shift_cnt IS
         WHEN '0' =>
                  rd_sm0_vhcg1_vhcg4 := rd_sm0_shift;
                  rd_sm1_vhcg2_vhcg5 := rd_sm1_shift;
         WHEN '1' =>
                  rd_sm0_vhcg1_vhcg4 := rd_sm1_shift;
                  rd_sm1_vhcg2_vhcg5 := rd_sm0_shift;
         WHEN OTHERS  =>


      END CASE;
      rd_sm0_vhcg1 <= rd_sm0_vhcg1_vhcg4;
      rd_sm1_vhcg2 <= rd_sm1_vhcg2_vhcg5;
   END PROCESS;

   PROCESS (shift_cnt, wr_sm0, wr_sm1)
      VARIABLE wr_sm0_shift_vhcg6  : std_logic_vector(8 - 1 DOWNTO 0);
      VARIABLE wr_sm1_shift_vhcg7  : std_logic_vector(8 - 1 DOWNTO 0);
   BEGIN
      CASE shift_cnt IS
         WHEN '0' =>
                  wr_sm0_shift_vhcg6 := wr_sm0;
                  wr_sm1_shift_vhcg7 := wr_sm1;
         WHEN '1' =>
                  wr_sm0_shift_vhcg6 := wr_sm1;
                  wr_sm1_shift_vhcg7 := wr_sm0;
         WHEN OTHERS  =>


      END CASE;
      wr_sm0_shift <= wr_sm0_shift_vhcg6;
      wr_sm1_shift <= wr_sm1_shift_vhcg7;
   END PROCESS;

   PROCESS (mclk, rst)
   BEGIN
      IF (rst = '1') THEN
         FOR i IN 0 TO (2 - 1) LOOP
            regfbank0(i) <= "00000000";
            regfbank1(i) <= "00000000";
         END LOOP;
      ELSIF (mclk'EVENT AND mclk = '1') THEN
         IF (valid = '1') THEN
            regfbank0(to_integer(adr0_shift)) <= wr_sm0_shift;
            regfbank1(to_integer(adr1_shift)) <= wr_sm1_shift;
         END IF;
      END IF;
   END PROCESS;
   rd_sm0_shift <= regfbank0(to_integer(adr0_shift)) ;
   rd_sm1_shift <= regfbank1(to_integer(adr1_shift)) ;

END translated;
